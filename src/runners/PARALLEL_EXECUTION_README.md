# Параллельное выполнение тестов UC модели

## Резюме возможностей

### Что работает:

1. **Параллельный запуск нескольких примеров одновременно** через Python multiprocessing
    - Можно запустить 10 примеров параллельно
    - Каждый примердолжается независимо

2. **Инкрементальная запись результатов в CSV**
    - Результаты записываются сразу после решения каждого примера
    - Если скрипт остановится, данные не потеряются

3. **Солверы**:
    - **CBC** - работает стабильно, но ограниченная многопоточность
    - **HiGHS** - установлен, но имеет проблемы с интеграцией Pyomo через ASL

### Оптимальная стратегия распараллеливания

Для системы с 16 CPU:

#### Вариант 1: Максимальный параллелизм (рекомендуется)

```bash
python run_all_tests_parallel.py --parallel 16 --threads-per-instance 1 --solver cbc
```

- 16 примеров решаются одновременно
- Каждому примеру 1 ядро
- Максимальная throughput

#### Вариант 2: Для больших примеров

```bash
python run_all_tests_parallel.py --parallel 4 --threads-per-instance 4 --solver cbc
```

- 4 примера решаются одновременно
- Каждому примеру 4 ядра
- Лучше для очень сложных примеров

## Использование

### Базовый запуск на всех примерах с максимальным параллелизмом

```bash
python run_all_tests_parallel.py --parallel 16 --solver cbc
```

### С ограничением времени на пример

```bash
python run_all_tests_parallel.py --parallel 10 --time-limit 300 --solver cbc
```

### Тестирование на небольшом подмножестве

```bash
python run_all_tests_parallel.py --limit 10 --parallel 5 --solver cbc
```

### С детальным выводом солвера

```bash
python run_all_tests_parallel.py --parallel 4 --verbose --solver cbc
```

## Параметры командной строки

```
--parallel N                   Количество параллельных процессов (default: 4)
--threads-per-instance N       Потоков на каждый solver (default: 2)
--solver {cbc,highs}          Выбор солвера (default: highs)
--gap FLOAT                    MIP gap tolerance (default: 0.01)
--time-limit SECONDS           Лимит времени на пример
--output FILE                  Файл для результатов CSV
--limit N                      Ограничить количество примеров
--instances FILE [FILE ...]    Конкретные примеры для запуска
--verbose                      Показывать вывод солвера
```

## Ожидаемая производительность

### Последовательный запуск (run_all_tests.py)

- Скорость: ~150-200 секунд на пример
- Всего на 56 примеров: **~2-3 часа**

### Параллельный запуск (run_all_tests_parallel.py)

С 16 параллельными процессами:

- Скорость: ~150-200 секунд на пример (но 16 одновременно!)
- Всего на 56 примеров: **~15-20 минут**
- **Ускорение: ~8-10x**

## Мониторинг прогресса

### 1. Проверка CSV файла в реальном времени

```bash
# Windows
type test_results_parallel.csv | findstr /C:"optimal"

# Подсчёт решённых примеров
python -c "import csv; print(len(list(csv.DictReader(open('test_results_parallel.csv')))))"
```

### 2. Отслеживание загрузки CPU

Открыть Диспетчер задач (Ctrl+Shift+Esc) и посмотреть загрузку CPU - должна быть близка к 100% при правильной настройке
параллелизма.

## Примеры запуска

### Быстрый тест на 4 примерах с 2 параллельными процессами

```bash
python run_all_tests_parallel.py --limit 4 --parallel 2 --output quick_test.csv
```

### Полный запуск с максимальной скоростью

```bash
python run_all_tests_parallel.py --parallel 16 --output all_results_fast.csv --solver cbc
```

### Запуск с ограничением времени (5 мин на пример)

```bash
python run_all_tests_parallel.py --parallel 10 --time-limit 300 --output results_limited.csv
```

## Результаты

Файл CSV содержит для каждого примера:

- `instance` - имя файла
- `status` - статус (optimal/feasible/error)
- `solve_time` - время решения солвером (сек)
- `build_time` - время построения модели (сек)
- `load_time` - время загрузки данных (сек)
- `total_time` - общее время (сек)
- `objective_value` - значение целевой функции
- `gap` - MIP gap при завершении (%)
- `error` - сообщение об ошибке (если есть)
- `file_path` - полный путь к файлу

В конце выполнения выводится summary со статистикой:

- Количество успешных/неудачных решений
- Мин/макс/средние времена решения
- **Speedup** - ускорение относительно последовательного выполнения
- Total wall-clock time - реальное время работы

## Рекомендации

1. **Для максимальной скорости**: Используйте `--parallel` равный числу CPU (или чуть меньше)

2. **Для стабильности**: Используйте `--parallel` = 50-75% от числа CPU

3. **При нехватке RAM**: Уменьшите `--parallel`, так как каждый процесс требует ~1-2 GB RAM

4. **Для отладки**: Используйте `--parallel 1 --verbose` для последовательного выполнения с детальным выводом

5. **Сохранение результатов**: Результаты записываются инкрементально, так что можно остановить выполнение в любой
   момент (Ctrl+C)
